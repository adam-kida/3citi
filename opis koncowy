Film: https://youtu.be/TMpsjCkqCqg

W zakładce Przystanki(StopsPage) wyświetlana jest lista Przystanków
W StopsViewModel 
var stops = await StopDataStore.GetItemsAsync(true);
przypisuje stops liste przystanków
StopDataStore.GetItemsAsync(true) wywołuję metodę z MockStopsDataStore,
która przypomocy HttpClient pobiera plik json zawierający listę przystanków.

Korzystając z Newtonsoft.Json plik.json jest deserializowany i tworzy listę
następnie dane są przetwarzane( w tym wypadku wybieranie przystanków z danego dnia)
przypisywane do listy i przekazywane dalej.

Wszystkie pliki Mock... stosują ten mechanizm, różnią się jedynie tym jak przetwarzają dane przed ich zwróceniem.

W MockRoutesDayDataStore dane są przetwarzane tak aby zwrócić listę która pozwoli wyświetlić dzni tygodnia a po wybraniu
jednego z nich będzie zawierała dane potrzebne do wyświetlenia listy linii które jeźdzą danego dnia.

Metody OnItemSelected w plikach xaml.cs

Interfejsy IRouteDataStore oraz pozostałe pozwalają zainicjować w BaseViewModel(po którym dziedziczą wszystke viewModel'e)
TripsDataStore oraz pozostałe, które ułatwiają komunikację z plikami Mock...(jeśli jest to potrzebne to pozwalają na 
tworzenie osobnych metod w zależności od platforny iOS Android UWP)

zmieniają wyświetlaną stronę oraz przekazują dane do kolejnego widoku.

zewzględu na Xamarin Forms muszą się tan znajdować dwa konstruktory,
jeden pusty, drugi przypisujący viewModel.

W plikach xaml niekrórym rzeczą trzeba przypisać źródło poprzez rzecz = "{Binding CoPrzypisać}"

W ViewModels
Przed konstruktorem są inicjalizowane wszystkie kolekcje, listy,inty ,stringi, boole i inne.
W ten sposób będą one niezależne od źródła które im przypisuje wartość.
Podczas pisania listy zainicjalizowane grębiej w kodzie po przypisaniu wartości a następnie zmianie źródła
równierz zmieniały zawartość.

SearchCommandExecute() zapisuje listę sprzed zmiany, aby móc ją odtworzyć.
Następnie w nowej zapisuje elementy które pasują do wyszukiwanej frazy.
Tutaj
Backup.Where(c => (c.RouteShortName.IndexOf(SearchedText, StringComparison.OrdinalIgnoreCase) >= 0) || (c.RouteLongName.IndexOf(SearchedText, StringComparison.OrdinalIgnoreCase) >= 0));
zastosowano Linq w celu wybrania tych elementów które pasują.
dodatkowe elementy pozwalają na ignorowanie rozmiary liter w wyszukiwanej frazie.

Pozostałe metody służą jedynie do pobrania brakujących danych których nie przekazał poprzedni element,
oraz odpowiednim ich przetwożeniu np. Obiekty z jednej listy mają parametr routeId a chcemy do nich dodać inne parametry danego 
Route jak Name, więc trzeba wyszukać na liście wszystkich Route takiego który będzie posiadał takie samo RouteId i przypisaniu 
jego Name do początkowego obiektu

W tych metodach łączy się obiekty w listy które mają wspólne parametry itp.

nastepnie przypisuje się przetwożone dane do kolekcji która jest przypisana jako źródło do wyświetlania.
